from enum import Enum
from collections import deque 

class BoatLocation(Enum):
    LEFT = -1
    RIGHT = 1

    
class SemanticNetsAgent:
    def __init__(self):
        # will consist of pairs 3-tuples of (left_sheep,left_wolves,boat_location)
        # where boat_location == -1 -> the boat is on the left
        # boat_location == 1 -> the boat is on the right
        # as this will provide a unique value to hash for every state
        # the tree generated by the Breadth First Search algorithm.
        # used for extracting the shortest path
        # the elements will be 2-tuples of (state,parent_state)
        self.BFS_tree = dict()

    def generate_next_valid_states(self,current_state,total_sheep,total_wolves):
        left_sheep = current_state[0]
        left_wolves = current_state[1]
        boat_location = current_state[2]

        # change the boat location (left -> right, right -> left)
        new_boat_location = BoatLocation.RIGHT if boat_location == BoatLocation.LEFT else BoatLocation.LEFT

        # all possible variations: (1,0),(0,1),(1,1),(2,0),(0,2)
        # this could of course be done algorithmically, and we can
        # avoid temporarily storing invalid states by checking inside a loop
        next_states_all = [ (left_sheep + boat_location.value, left_wolves, new_boat_location),
                            (left_sheep,left_wolves + boat_location.value, new_boat_location),
                            (left_sheep + boat_location.value,left_wolves + boat_location.value, new_boat_location),
                            (left_sheep + 2*boat_location.value,left_wolves, new_boat_location),
                            (left_sheep, left_wolves + 2*boat_location.value, new_boat_location),
                            ]
        
        next_states_valid = []

        for state in next_states_all:
            
            new_left_sheep = state[0]
            new_left_wolves = state[1]
            new_right_sheep = total_sheep - new_left_sheep
            new_right_wolves = total_wolves - new_left_wolves

            # if we took more animals than available, the state transition was invalid 
            # (checking for the right side is redundant)
            if new_left_sheep < 0 or new_left_wolves < 0 or new_left_sheep > total_sheep or new_left_wolves > total_wolves:
                continue

            # if it's an already visited state
            if state in self.BFS_tree:
                continue

            # if at least one sheep and more wolves than sheep on either side
            if (new_left_sheep != 0 and new_left_sheep < new_left_wolves) or (
                new_right_sheep != 0 and new_right_sheep < new_right_wolves):
                continue

            # else it's a valid next state
            next_states_valid.append(state)

        return next_states_valid
            


    def solve(self, initial_sheep, initial_wolves):

        # clear data from previous call
        self.BFS_tree = dict()

        initial_state = (initial_sheep,initial_wolves, BoatLocation.LEFT)
        target_state = (0,0,BoatLocation.RIGHT)


        # -1 means it's the root
        self.BFS_tree[initial_state] = -1

        running_queue = deque([initial_state])


        iteration_depth = 0

        # while there are still states left to process and we haven't reached the target,
        # do a Breadth First Search
        while len(running_queue) != 0 and running_queue[0] != target_state:

            running_state = running_queue.popleft()

            valid_next_states = self.generate_next_valid_states(running_state,initial_sheep,initial_wolves)

            for valid_next_state in valid_next_states:
                self.BFS_tree[valid_next_state] = running_state
                running_queue.append(valid_next_state)

            iteration_depth += 1




        return self.extract_moves(target_state,initial_state)
        
    def extract_moves(self,target_state,initial_state):

        # if the target state was unreachable
        if target_state not in self.BFS_tree:
            return []
        
        moves = []


        running_state = target_state

        # while we haven't reached the root
        while self.BFS_tree[running_state] != -1:

            left_sheep_before = self.BFS_tree[running_state][0]
            left_sheep_after = running_state[0]
            left_wolves_before = self.BFS_tree[running_state][1]
            left_wolves_after = running_state[1]

            moves.append((abs(left_sheep_after - left_sheep_before),abs(left_wolves_after - left_wolves_before)))

            running_state = self.BFS_tree[running_state]

        moves.reverse()

        return moves


